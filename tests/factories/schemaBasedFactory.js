/**
 * ========================================
 * FACTORY BASÉE SUR SCHÉMA SQL
 * ========================================
 * Génération automatique de données de test valides
 * @version 1.0.0
 */

const { faker } = require('@faker-js/faker');

class SchemaBasedFactory {
  constructor(schemaExtractor) {
    this.schemaExtractor = schemaExtractor;
    this.schemas = new Map();
    this.fakers = new Map();
    this.initializeFakers();
  }

  /**
   * Initialise les générateurs de données par type
   */
  initializeFakers() {
    this.fakers.set('varchar', (column) => 
      faker.lorem.words(Math.ceil((column.maxLength || 50) / 6)).substring(0, column.maxLength || 255)
    );
    
    this.fakers.set('text', () => faker.lorem.paragraphs(3));
    
    this.fakers.set('integer', (column) => 
      faker.datatype.number({ 
        min: column.precision ? 1 : 0,
        max: Math.pow(10, Math.min(column.precision || 9, 9)) - 1
      })
    );
    
    this.fakers.set('bigint', () => 
      faker.datatype.number({ min: 1, max: 9223372036854775807 })
    );
    
    this.fakers.set('numeric', (column) => 
      parseFloat(faker.datatype.number({
        min: 0,
        max: Math.pow(10, (column.precision || 10) - (column.scale || 2)) - 1,
        precision: column.scale || 2
      }).toFixed(column.scale || 2))
    );
    
    this.fakers.set('decimal', (column) => 
      parseFloat(faker.datatype.number({
        min: 0,
        max: Math.pow(10, (column.precision || 10) - (column.scale || 2)) - 1,
        precision: column.scale || 2
      }).toFixed(column.scale || 2))
    );
    
    this.fakers.set('timestamp', () => faker.date.future());
    this.fakers.set('timestamptz', () => faker.date.future());
    this.fakers.set('boolean', () => faker.datatype.boolean());
    this.fakers.set('uuid', () => faker.datatype.uuid());
    this.fakers.set('json', () => faker.helpers.objectValue());
    this.fakers.set('jsonb', () => faker.helpers.objectValue());
    
    // Types spécifiques PostgreSQL
    this.fakers.set('character varying', (column) => 
      faker.lorem.words(Math.ceil((column.maxLength || 50) / 6)).substring(0, column.maxLength || 255)
    );
    
    this.fakers.set('character', (column) => 
      faker.lorem.words(1).substring(0, column.maxLength || 1)
    );
  }

  /**
   * Génère des données valides pour une table
   */
  async generate(tableName, overrides = {}) {
    if (!this.schemas.has(tableName)) {
      await this.loadSchema(tableName);
    }

    const schema = this.schemas.get(tableName);
    if (!schema) {
      throw new Error(`Schéma non trouvé pour la table: ${tableName}`);
    }

    return this.generateFromSchema(schema, overrides);
  }

  /**
   * Charge le schéma d'une table
   */
  async loadSchema(tableName) {
    try {
      // 1. Extraire depuis la base de données
      const dbSchema = await this.schemaExtractor.extractFromDatabase(tableName);
      
      // 2. Extraire depuis le repository
      const repoPath = `../src/modules/${this.singularize(tableName)}/${this.singularize(tableName)}.repository`;
      let repoSchema = null;
      
      try {
        repoSchema = await this.schemaExtractor.extractFromRepository(repoPath);
      } catch (error) {
        console.warn(`⚠️ Repository non trouvé pour ${tableName}: ${error.message}`);
      }
      
      // 3. Fusionner les schémas
      const mergedSchema = this.schemaExtractor.mergeSchemas(dbSchema, repoSchema);
      
      this.schemas.set(tableName, mergedSchema);
      console.log(`✅ Schéma chargé pour ${tableName}: ${Object.keys(mergedSchema.columns).length} colonnes`);
      
    } catch (error) {
      console.error(`❌ Erreur chargement schéma ${tableName}:`, error.message);
      throw error;
    }
  }

  /**
   * Génère des données depuis un schéma
   */
  generateFromSchema(schema, overrides = {}) {
    const data = {};
    
    // Générer les valeurs pour chaque colonne
    for (const [columnName, column] of Object.entries(schema.columns)) {
      // Si override fourni, l'utiliser
      if (overrides[columnName] !== undefined) {
        data[columnName] = overrides[columnName];
        continue;
      }

      // Ignorer les colonnes auto-générées (serial, default)
      if (this.isAutoGenerated(column)) {
        continue;
      }

      // Générer une valeur valide selon le type
      data[columnName] = this.generateValueForColumn(column, schema);
    }

    // Appliquer les contraintes
    this.applyConstraints(data, schema);

    return data;
  }

  /**
   * Génère une valeur pour une colonne spécifique
   */
  generateValueForColumn(column, schema) {
    // Gérer les colonnes avec des règles spécifiques
    if (this.hasSpecialRules(column.name)) {
      return this.applySpecialRules(column.name, column, schema);
    }

    // Utiliser le faker approprié
    const faker = this.fakers.get(column.type) || this.fakers.get(column.udtName);
    
    if (faker) {
      return faker(column);
    }

    // Valeur par défaut selon le type
    switch (column.type) {
      case 'varchar':
      case 'text':
        return column.name.includes('email') ? faker.internet.email() :
               column.name.includes('url') ? faker.internet.url() :
               column.name.includes('phone') ? faker.phone.number() :
               faker.lorem.words(3);
      
      case 'integer':
      case 'bigint':
        return faker.datatype.number({ min: 1, max: 1000000 });
      
      case 'numeric':
      case 'decimal':
        return parseFloat(faker.datatype.number({ min: 0, max: 1000, precision: 2 }).toFixed(2));
      
      case 'timestamp':
      case 'timestamptz':
        return column.name.includes('created_at') || column.name.includes('updated_at') 
          ? new Date() 
          : faker.date.future();
      
      case 'boolean':
        return faker.datatype.boolean();
      
      case 'uuid':
        return faker.datatype.uuid();
      
      default:
        return null;
    }
  }

  /**
   * Vérifie si une colonne est auto-générée
   */
  isAutoGenerated(column) {
    return column.default && (
      column.default.includes('nextval') ||
      column.default.includes('gen_random_uuid') ||
      column.default.includes('NOW()')
    );
  }

  /**
   * Vérifie si une colonne a des règles spéciales
   */
  hasSpecialRules(columnName) {
    const specialColumns = [
      'email', 'phone', 'url', 'status', 'type', 'role',
      'password', 'token', 'code', 'price', 'currency',
      'first_name', 'last_name', 'title', 'description',
      'event_date', 'start_date', 'end_date', 'location'
    ];
    
    return specialColumns.some(special => columnName.toLowerCase().includes(special));
  }

  /**
   * Applique des règles spéciales pour certaines colonnes
   */
  applySpecialRules(columnName, column, schema) {
    const name = columnName.toLowerCase();
    
    // Règles pour les emails
    if (name.includes('email')) {
      return faker.internet.email();
    }
    
    // Règles pour les téléphones
    if (name.includes('phone')) {
      return faker.phone.number('+33 6 ## ## ## ##');
    }
    
    // Règles pour les URLs
    if (name.includes('url')) {
      return faker.internet.url();
    }
    
    // Règles pour les statuts
    if (name.includes('status')) {
      const statuses = ['draft', 'published', 'archived', 'cancelled', 'active', 'inactive'];
      return faker.helpers.arrayElement(statuses);
    }
    
    // Règles pour les types
    if (name.includes('type')) {
      const types = ['standard', 'vip', 'premium', 'free', 'paid'];
      return faker.helpers.arrayElement(types);
    }
    
    // Règles pour les rôles
    if (name.includes('role')) {
      const roles = ['admin', 'organizer', 'user', 'guest'];
      return faker.helpers.arrayElement(roles);
    }
    
    // Règles pour les mots de passe
    if (name.includes('password')) {
      return faker.internet.password(12, true, /[A-Z]/, 'Test123!');
    }
    
    // Règles pour les tokens/codes
    if (name.includes('token') || name.includes('code')) {
      return faker.random.alphaNumeric(16).toUpperCase();
    }
    
    // Règles pour les prix
    if (name.includes('price')) {
      return parseFloat(faker.datatype.number({ min: 0, max: 1000, precision: 2 }).toFixed(2));
    }
    
    // Règles pour les devises
    if (name.includes('currency')) {
      return 'EUR';
    }
    
    // Règles pour les noms
    if (name.includes('first_name')) {
      return faker.person.firstName();
    }
    
    if (name.includes('last_name')) {
      return faker.person.lastName();
    }
    
    // Règles pour les titres
    if (name.includes('title')) {
      return faker.lorem.sentence(3);
    }
    
    // Règles pour les descriptions
    if (name.includes('description')) {
      return faker.lorem.paragraph();
    }
    
    // Règles pour les dates d'événement
    if (name.includes('event_date') || name.includes('start_date')) {
      return faker.date.future({ years: 1 });
    }
    
    if (name.includes('end_date')) {
      const startDate = faker.date.future({ years: 1 });
      return faker.date.soon({ days: 30, refDate: startDate });
    }
    
    // Règles pour les localisations
    if (name.includes('location')) {
      return `${faker.location.city()}, ${faker.location.country()}`;
    }
    
    // Fallback au faker par défaut
    const defaultFaker = this.fakers.get(column.type) || this.fakers.get(column.udtName);
    return defaultFaker ? defaultFaker(column) : null;
  }

  /**
   * Applique les contraintes du schéma
   */
  applyConstraints(data, schema) {
    // S'assurer que les clés primaires sont uniques (si générées)
    if (schema.constraints.primary.length > 0) {
      const primaryKey = schema.constraints.primary[0];
      if (data[primaryKey] && typeof data[primaryKey] === 'number') {
        data[primaryKey] = Math.abs(data[primaryKey]) + Math.floor(Math.random() * 1000000);
      }
    }
    
    // S'assurer que les clés étrangères sont valides
    schema.constraints.foreign.forEach(fk => {
      if (data[fk.column]) {
        // Pour les tests, on utilise des IDs positifs
        if (typeof data[fk.column] === 'number') {
          data[fk.column] = Math.abs(data[fk.column]) || 1;
        }
      }
    });
    
    // S'assurer que les timestamps sont cohérents
    if (data.created_at && data.updated_at) {
      data.updated_at = new Date(Math.max(data.created_at.getTime(), data.updated_at.getTime()));
    }
  }

  /**
   * Génère plusieurs enregistrements
   */
  async generateMany(tableName, count, overrides = {}) {
    const records = [];
    
    for (let i = 0; i < count; i++) {
      const record = await this.generate(tableName, overrides);
      records.push(record);
    }
    
    return records;
  }

  /**
   * Crée des données relationnelles
   */
  async generateWithRelations(tableName, overrides = {}) {
    if (!this.schemas.has(tableName)) {
      await this.loadSchema(tableName);
    }

    const schema = this.schemas.get(tableName);
    const data = {};
    const relatedData = {};

    // Générer les données pour les relations
    for (const relationship of schema.relationships) {
      if (relationship.type === 'belongsTo') {
        const relatedTable = relationship.foreignTable;
        
        if (!relatedData[relatedTable]) {
          relatedData[relatedTable] = await this.generate(relatedTable);
        }
        
        data[relationship.localKey] = relatedData[relatedTable].id;
      }
    }

    // Générer les données principales
    const mainData = await this.generate(tableName, { ...data, ...overrides });
    
    return {
      ...mainData,
      related: relatedData
    };
  }

  /**
   * Helper pour singulariser les noms de table
   */
  singularize(tableName) {
    if (tableName.endsWith('ies')) {
      return tableName.slice(0, -3) + 'y';
    }
    if (tableName.endsWith('s') && !tableName.endsWith('ss')) {
      return tableName.slice(0, -1);
    }
    return tableName;
  }

  /**
   * Vide le cache des schémas
   */
  clearCache() {
    this.schemas.clear();
  }

  /**
   * Retourne les schémas chargés
   */
  getLoadedSchemas() {
    return Array.from(this.schemas.keys());
  }
}

module.exports = SchemaBasedFactory;
