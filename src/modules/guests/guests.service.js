const guestsRepository = require('./guests.repository');
const { v4: uuidv4 } = require('uuid');
const { ensureGuestAuthAccount } = require('./guest-auth.helper');
const eventsRepository = require('../events/events.repository');

class GuestsService {
  async ensureEventAcceptsGuests(eventId) {
    const event = await eventsRepository.findById(eventId);
    if (!event) {
      throw new Error('Event not found');
    }
    if (event.status === 'archived') {
      throw new Error('Cannot add guests to an archived event');
    }
  }

  async createGuest(guestData, userId) {
    try {
      // Check if email already exists
      if (guestData.email) {
        const existingGuest = await guestsRepository.findByEmail(guestData.email);
        if (existingGuest) {
          return {
            success: false,
            error: 'Guest with this email already exists'
          };
        }
      }

      const guestDataWithCreator = {
        ...guestData,
        // Note: id is auto-generated by PostgreSQL (BIGSERIAL)
        created_by: userId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      const guest = await guestsRepository.create(guestDataWithCreator);

      try {
        await ensureGuestAuthAccount(guest);
      } catch (error) {
        console.warn('Failed to provision guest auth account:', {
          email: guest.email,
          error: error.message
        });
      }
      
      return {
        success: true,
        data: guest
      };
    } catch (error) {
      console.error('Error creating guest:', error);
      return {
        success: false,
        error: error.message || 'Failed to create guest'
      };
    }
  }

  async getGuestById(guestId, userId) {
    try {
      const guest = await guestsRepository.findById(guestId);
      
      if (!guest) {
        return {
          success: false,
          error: 'Guest not found'
        };
      }

      return {
        success: true,
        data: guest
      };
    } catch (error) {
      console.error('Error getting guest by ID:', error);
      return {
        success: false,
        error: error.message || 'Failed to get guest'
      };
    }
  }

  async getGuests(options = {}) {
    try {
      const { page, limit, status, search, userId } = options;
      const guests = await guestsRepository.findAll({
        page: page ? parseInt(page) : 1,
        limit: limit ? parseInt(limit) : 10,
        status,
        search,
        userId
      });
      
      return {
        success: true,
        data: guests,
        pagination: guests.pagination
      };
    } catch (error) {
      console.error('Error getting guests:', error);
      return {
        success: false,
        error: error.message || 'Failed to get guests'
      };
    }
  }

  async updateGuest(guestId, updateData, userId) {
    try {
      const existingGuest = await guestsRepository.findById(guestId);
      
      if (!existingGuest) {
        return {
          success: false,
          error: 'Guest not found'
        };
      }

      const updatedGuest = await guestsRepository.update(guestId, {
        ...updateData,
        updated_by: userId,
        updated_at: new Date().toISOString()
      });

      return {
        success: true,
        data: updatedGuest
      };
    } catch (error) {
      console.error('Error updating guest:', error);
      return {
        success: false,
        error: error.message || 'Failed to update guest'
      };
    }
  }

  async deleteGuest(guestId, userId) {
    try {
      const existingGuest = await guestsRepository.findById(guestId);
      
      if (!existingGuest) {
        return {
          success: false,
          error: 'Guest not found'
        };
      }

      await guestsRepository.delete(guestId);

      return {
        success: true,
        data: { id: guestId, deleted: true }
      };
    } catch (error) {
      console.error('Error deleting guest:', error);
      return {
        success: false,
        error: error.message || 'Failed to delete guest'
      };
    }
  }

  async getEventGuests(eventId, options = {}) {
    try {
      const { page, limit, status, userId } = options;
      const guests = await guestsRepository.findByEventId(eventId, {
        page: page ? parseInt(page) : 1,
        limit: limit ? parseInt(limit) : 10,
        status,
        userId
      });
      
      return {
        success: true,
        data: guests,
        pagination: guests.pagination
      };
    } catch (error) {
      console.error('Error getting event guests:', error);
      return {
        success: false,
        error: error.message || 'Failed to get event guests'
      };
    }
  }

  async getEventGuestAssociations(eventId, options = {}) {
    try {
      const { page, limit, status, userId } = options;
      const eventGuests = await guestsRepository.findEventGuestAssociationsByEventId(eventId, {
        page: page ? parseInt(page) : 1,
        limit: limit ? parseInt(limit) : 10,
        status,
        userId
      });
      
      return {
        success: true,
        data: eventGuests,
        pagination: eventGuests.pagination
      };
    } catch (error) {
      console.error('Error getting event guest associations:', error);
      return {
        success: false,
        error: error.message || 'Failed to get event guest associations'
      };
    }
  }

  async addGuestsToEvent(eventId, guests, userId) {
    try {
      // Validation des entrées
      if (!eventId) {
        throw new Error('Event ID is required');
      }

      await this.ensureEventAcceptsGuests(eventId);
      
      if (!guests || !Array.isArray(guests)) {
        throw new Error('Guests must be an array');
      }
      
      if (guests.length === 0) {
        throw new Error('At least one guest is required');
      }
      
      const addedGuests = [];
      const eventGuestsData = [];
      
      for (const guest of guests) {
        let guestRecord;
        
        if (guest.guest_id) {
          // Cas 1: Lier un invité existant à l'événement
          guestRecord = await guestsRepository.findById(guest.guest_id);
          if (!guestRecord) {
            throw new Error(`Guest with ID ${guest.guest_id} not found`);
          }
          
          // Créer la liaison event_guests
          eventGuestsData.push({
            guest_id: guest.guest_id,
            event_id: eventId,
            created_by: userId,
            updated_by: userId
          });
        } else {
          // Cas 2: Créer un nouvel invité puis le lier à l'événement
          // Gérer le nom (split name en first_name et last_name)
          let firstName = guest.first_name;
          let lastName = guest.last_name;

          if (guest.name && !guest.first_name && !guest.last_name) {
            const nameParts = guest.name.trim().split(' ');
            firstName = nameParts[0] || '';
            lastName = nameParts.slice(1).join(' ') || '';
          }

          if (!firstName || firstName.trim() === '') {
            throw new Error('first_name is required when creating a new guest');
          }

          const guestData = {
            first_name: firstName.trim(),
            last_name: lastName ? lastName.trim() : null,
            email: guest.email || null,
            phone: guest.phone || null,
            created_by: userId,
            updated_by: userId,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };

          guestRecord = await guestsRepository.create(guestData);

          try {
            await ensureGuestAuthAccount(guestRecord);
          } catch (error) {
            console.warn('Failed to provision guest auth account:', {
              email: guestRecord.email,
              error: error.message
            });
          }
          
          // Créer la liaison event_guests
          eventGuestsData.push({
            guest_id: guestRecord.id,
            event_id: eventId,
            created_by: userId,
            updated_by: userId
          });
        }
        
        addedGuests.push(guestRecord);
      }
      
      // Créer toutes les liaisons event_guests en une seule fois
      if (eventGuestsData.length > 0) {
        await guestsRepository.bulkCreateEventGuests(eventGuestsData);
      }
      
      return {
        success: true,
        data: addedGuests
      };
    } catch (error) {
      console.error('Error adding guests to event:', error);
      return {
        success: false,
        error: error.message || 'Failed to add guests to event'
      };
    }
  }

  async bulkAddGuestsToEvent(eventId, guests, userId) {
    try {
      // Validation des entrées
      if (!eventId) {
        throw new Error('Event ID is required');
      }

      await this.ensureEventAcceptsGuests(eventId);

      if (!guests || !Array.isArray(guests)) {
        throw new Error('Guests must be an array');
      }

      if (guests.length === 0) {
        throw new Error('At least one guest is required');
      }

      const addedGuests = [];
      const eventGuestsData = [];

      const existingGuestIds = [];
      const newGuestsData = [];

      for (const guest of guests) {
        if (guest.guest_id) {
          existingGuestIds.push(guest.guest_id);
          continue;
        }

        // Nouveau guest: normaliser name -> first/last
        let firstName = guest.first_name;
        let lastName = guest.last_name;

        if (guest.name && !guest.first_name && !guest.last_name) {
          const nameParts = guest.name.trim().split(' ');
          firstName = nameParts[0] || '';
          lastName = nameParts.slice(1).join(' ') || '';
        }

        if (!firstName || firstName.trim() === '') {
          throw new Error('first_name is required when creating a new guest');
        }

        if (!guest.email) {
          throw new Error('email is required when creating a new guest');
        }

        newGuestsData.push({
          first_name: firstName.trim(),
          last_name: lastName ? lastName.trim() : null,
          email: guest.email,
          phone: guest.phone || null,
          created_by: userId,
          updated_by: userId
        });
      }

      if (existingGuestIds.length > 0) {
        const existingGuests = await Promise.all(
          existingGuestIds.map(async (guestId) => {
            const guestRecord = await guestsRepository.findById(guestId);
            if (!guestRecord) {
              throw new Error(`Guest with ID ${guestId} not found`);
            }
            return guestRecord;
          })
        );

        for (const guestRecord of existingGuests) {
          addedGuests.push(guestRecord);
          eventGuestsData.push({
            guest_id: guestRecord.id,
            event_id: eventId,
            created_by: userId,
            updated_by: userId
          });
        }
      }

      if (newGuestsData.length > 0) {
        const createdGuests = await guestsRepository.bulkCreate(newGuestsData);
        for (const guestRecord of createdGuests) {
          addedGuests.push(guestRecord);
          eventGuestsData.push({
            guest_id: guestRecord.id,
            event_id: eventId,
            created_by: userId,
            updated_by: userId
          });

          if (guestRecord?.email) {
            try {
              await ensureGuestAuthAccount(guestRecord);
            } catch (error) {
              console.warn('Failed to provision guest auth account:', {
                email: guestRecord.email,
                error: error.message
              });
            }
          }
        }
      }

      let associations = [];
      if (eventGuestsData.length > 0) {
        associations = await guestsRepository.bulkCreateEventGuests(eventGuestsData);
      }
      
      return {
        success: true,
        data: {
          guests: addedGuests,
          associations
        }
      };
    } catch (error) {
      console.error('Error bulk adding guests to event:', error);
      return {
        success: false,
        error: error.message || 'Failed to bulk add guests to event'
      };
    }
  }

  async checkInGuest(guestId, eventId, userId) {
    try {
      const checkInData = {
        guest_id: guestId,
        event_id: eventId,
        checked_in_at: new Date().toISOString()
      };

      const checkIn = await guestsRepository.checkIn(checkInData);
      
      return {
        success: true,
        data: checkIn
      };
    } catch (error) {
      console.error('Error checking in guest:', error);
      return {
        success: false,
        error: error.message || 'Failed to check in guest'
      };
    }
  }

  async checkInGuestById(guestId, eventId, userId) {
    try {
      // Vérifier si l'invité existe et est lié à l'événement
      const eventGuest = await guestsRepository.findEventGuest(guestId, eventId);
      
      if (!eventGuest) {
        return {
          success: false,
          error: 'Guest does not belong to this event'
        };
      }

      const checkInData = {
        guest_id: guestId,
        event_id: eventId,
        checked_in_at: new Date().toISOString()
      };

      const checkIn = await guestsRepository.checkIn(checkInData);
      
      return {
        success: true,
        data: checkIn
      };
    } catch (error) {
      console.error('Error checking in guest by ID:', error);
      return {
        success: false,
        error: error.message || 'Failed to check in guest'
      };
    }
  }

  async getEventGuestStats(eventId, userId) {
    try {
      const stats = await guestsRepository.getEventStats(eventId);
      const guests = await guestsRepository.findByEventId(eventId, { page: 1, limit: 1000 });
      
      return {
        success: true,
        data: {
          ...stats,
          guests: guests || [],
          guests_count: Array.isArray(guests) ? guests.length : 0
        }
      };
    } catch (error) {
      console.error('Error getting event guest stats:', error);
      return {
        success: false,
        error: error.message || 'Failed to get event guest statistics'
      };
    }
  }
}

module.exports = new GuestsService();
